// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: MessageRouting.proto

#ifndef PROTOBUF_MessageRouting_2eproto__INCLUDED
#define PROTOBUF_MessageRouting_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace common {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_MessageRouting_2eproto();
void protobuf_AssignDesc_MessageRouting_2eproto();
void protobuf_ShutdownFile_MessageRouting_2eproto();

class HeartbeatInit;
class HeartbeatInitResponse;
class Heartbeat;
class HeartbeatResponse;
class UserLogin;
class UserLoginResponse;
class UserLogout;
class UserLogoutResponse;
class Message;
class MessageResponse;
class ReceiveMessageAck;
class NormalMessage;
class NormalMessageAck;

enum MessageCommand {
  HEARTBEAT_INIT = 0,
  HEARTBEAT = 1,
  USER_LOGIN = 2,
  USER_LOGOUT = 3,
  MESSAGE = 4,
  RECEIVE_MESSAGE_ACK = 5,
  NORMARL_MESSAGE_ACK = 6,
  HEARTBEAT_INIT_RESPONSE = 100,
  HEARTBEAT_RESPONSE = 101,
  USER_LOGIN_RESPONSE = 102,
  USER_LOGOUT_RESPONSE = 103,
  MESSAGE_RESPONSE = 104,
  RECEIVE_MESSAGE = 200,
  NORMARL_MESSAGE = 201
};
bool MessageCommand_IsValid(int value);
const MessageCommand MessageCommand_MIN = HEARTBEAT_INIT;
const MessageCommand MessageCommand_MAX = NORMARL_MESSAGE;
const int MessageCommand_ARRAYSIZE = MessageCommand_MAX + 1;

const ::google::protobuf::EnumDescriptor* MessageCommand_descriptor();
inline const ::std::string& MessageCommand_Name(MessageCommand value) {
  return ::google::protobuf::internal::NameOfEnum(
    MessageCommand_descriptor(), value);
}
inline bool MessageCommand_Parse(
    const ::std::string& name, MessageCommand* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MessageCommand>(
    MessageCommand_descriptor(), name, value);
}
// ===================================================================

class HeartbeatInit : public ::google::protobuf::Message {
 public:
  HeartbeatInit();
  virtual ~HeartbeatInit();

  HeartbeatInit(const HeartbeatInit& from);

  inline HeartbeatInit& operator=(const HeartbeatInit& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HeartbeatInit& default_instance();

  void Swap(HeartbeatInit* other);

  // implements Message ----------------------------------------------

  HeartbeatInit* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HeartbeatInit& from);
  void MergeFrom(const HeartbeatInit& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 last_timeout = 1;
  inline bool has_last_timeout() const;
  inline void clear_last_timeout();
  static const int kLastTimeoutFieldNumber = 1;
  inline ::google::protobuf::int32 last_timeout() const;
  inline void set_last_timeout(::google::protobuf::int32 value);

  // optional string extra = 2;
  inline bool has_extra() const;
  inline void clear_extra();
  static const int kExtraFieldNumber = 2;
  inline const ::std::string& extra() const;
  inline void set_extra(const ::std::string& value);
  inline void set_extra(const char* value);
  inline void set_extra(const char* value, size_t size);
  inline ::std::string* mutable_extra();
  inline ::std::string* release_extra();
  inline void set_allocated_extra(::std::string* extra);

  // @@protoc_insertion_point(class_scope:common.HeartbeatInit)
 private:
  inline void set_has_last_timeout();
  inline void clear_has_last_timeout();
  inline void set_has_extra();
  inline void clear_has_extra();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* extra_;
  ::google::protobuf::int32 last_timeout_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_MessageRouting_2eproto();
  friend void protobuf_AssignDesc_MessageRouting_2eproto();
  friend void protobuf_ShutdownFile_MessageRouting_2eproto();

  void InitAsDefaultInstance();
  static HeartbeatInit* default_instance_;
};
// -------------------------------------------------------------------

class HeartbeatInitResponse : public ::google::protobuf::Message {
 public:
  HeartbeatInitResponse();
  virtual ~HeartbeatInitResponse();

  HeartbeatInitResponse(const HeartbeatInitResponse& from);

  inline HeartbeatInitResponse& operator=(const HeartbeatInitResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HeartbeatInitResponse& default_instance();

  void Swap(HeartbeatInitResponse* other);

  // implements Message ----------------------------------------------

  HeartbeatInitResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HeartbeatInitResponse& from);
  void MergeFrom(const HeartbeatInitResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 next_heartbeat = 1;
  inline bool has_next_heartbeat() const;
  inline void clear_next_heartbeat();
  static const int kNextHeartbeatFieldNumber = 1;
  inline ::google::protobuf::int32 next_heartbeat() const;
  inline void set_next_heartbeat(::google::protobuf::int32 value);

  // optional string extra = 2;
  inline bool has_extra() const;
  inline void clear_extra();
  static const int kExtraFieldNumber = 2;
  inline const ::std::string& extra() const;
  inline void set_extra(const ::std::string& value);
  inline void set_extra(const char* value);
  inline void set_extra(const char* value, size_t size);
  inline ::std::string* mutable_extra();
  inline ::std::string* release_extra();
  inline void set_allocated_extra(::std::string* extra);

  // @@protoc_insertion_point(class_scope:common.HeartbeatInitResponse)
 private:
  inline void set_has_next_heartbeat();
  inline void clear_has_next_heartbeat();
  inline void set_has_extra();
  inline void clear_has_extra();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* extra_;
  ::google::protobuf::int32 next_heartbeat_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_MessageRouting_2eproto();
  friend void protobuf_AssignDesc_MessageRouting_2eproto();
  friend void protobuf_ShutdownFile_MessageRouting_2eproto();

  void InitAsDefaultInstance();
  static HeartbeatInitResponse* default_instance_;
};
// -------------------------------------------------------------------

class Heartbeat : public ::google::protobuf::Message {
 public:
  Heartbeat();
  virtual ~Heartbeat();

  Heartbeat(const Heartbeat& from);

  inline Heartbeat& operator=(const Heartbeat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Heartbeat& default_instance();

  void Swap(Heartbeat* other);

  // implements Message ----------------------------------------------

  Heartbeat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Heartbeat& from);
  void MergeFrom(const Heartbeat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 last_delay = 1;
  inline bool has_last_delay() const;
  inline void clear_last_delay();
  static const int kLastDelayFieldNumber = 1;
  inline ::google::protobuf::int32 last_delay() const;
  inline void set_last_delay(::google::protobuf::int32 value);

  // optional string extra = 2;
  inline bool has_extra() const;
  inline void clear_extra();
  static const int kExtraFieldNumber = 2;
  inline const ::std::string& extra() const;
  inline void set_extra(const ::std::string& value);
  inline void set_extra(const char* value);
  inline void set_extra(const char* value, size_t size);
  inline ::std::string* mutable_extra();
  inline ::std::string* release_extra();
  inline void set_allocated_extra(::std::string* extra);

  // @@protoc_insertion_point(class_scope:common.Heartbeat)
 private:
  inline void set_has_last_delay();
  inline void clear_has_last_delay();
  inline void set_has_extra();
  inline void clear_has_extra();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* extra_;
  ::google::protobuf::int32 last_delay_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_MessageRouting_2eproto();
  friend void protobuf_AssignDesc_MessageRouting_2eproto();
  friend void protobuf_ShutdownFile_MessageRouting_2eproto();

  void InitAsDefaultInstance();
  static Heartbeat* default_instance_;
};
// -------------------------------------------------------------------

class HeartbeatResponse : public ::google::protobuf::Message {
 public:
  HeartbeatResponse();
  virtual ~HeartbeatResponse();

  HeartbeatResponse(const HeartbeatResponse& from);

  inline HeartbeatResponse& operator=(const HeartbeatResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HeartbeatResponse& default_instance();

  void Swap(HeartbeatResponse* other);

  // implements Message ----------------------------------------------

  HeartbeatResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HeartbeatResponse& from);
  void MergeFrom(const HeartbeatResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 next_heartbeat = 1;
  inline bool has_next_heartbeat() const;
  inline void clear_next_heartbeat();
  static const int kNextHeartbeatFieldNumber = 1;
  inline ::google::protobuf::int32 next_heartbeat() const;
  inline void set_next_heartbeat(::google::protobuf::int32 value);

  // optional string extra = 2;
  inline bool has_extra() const;
  inline void clear_extra();
  static const int kExtraFieldNumber = 2;
  inline const ::std::string& extra() const;
  inline void set_extra(const ::std::string& value);
  inline void set_extra(const char* value);
  inline void set_extra(const char* value, size_t size);
  inline ::std::string* mutable_extra();
  inline ::std::string* release_extra();
  inline void set_allocated_extra(::std::string* extra);

  // @@protoc_insertion_point(class_scope:common.HeartbeatResponse)
 private:
  inline void set_has_next_heartbeat();
  inline void clear_has_next_heartbeat();
  inline void set_has_extra();
  inline void clear_has_extra();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* extra_;
  ::google::protobuf::int32 next_heartbeat_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_MessageRouting_2eproto();
  friend void protobuf_AssignDesc_MessageRouting_2eproto();
  friend void protobuf_ShutdownFile_MessageRouting_2eproto();

  void InitAsDefaultInstance();
  static HeartbeatResponse* default_instance_;
};
// -------------------------------------------------------------------

class UserLogin : public ::google::protobuf::Message {
 public:
  UserLogin();
  virtual ~UserLogin();

  UserLogin(const UserLogin& from);

  inline UserLogin& operator=(const UserLogin& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserLogin& default_instance();

  void Swap(UserLogin* other);

  // implements Message ----------------------------------------------

  UserLogin* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserLogin& from);
  void MergeFrom(const UserLogin& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline const ::std::string& user_id() const;
  inline void set_user_id(const ::std::string& value);
  inline void set_user_id(const char* value);
  inline void set_user_id(const char* value, size_t size);
  inline ::std::string* mutable_user_id();
  inline ::std::string* release_user_id();
  inline void set_allocated_user_id(::std::string* user_id);

  // optional string channel = 2;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 2;
  inline const ::std::string& channel() const;
  inline void set_channel(const ::std::string& value);
  inline void set_channel(const char* value);
  inline void set_channel(const char* value, size_t size);
  inline ::std::string* mutable_channel();
  inline ::std::string* release_channel();
  inline void set_allocated_channel(::std::string* channel);

  // optional string version = 3;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 3;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // optional string token = 4;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 4;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // optional string extra = 5;
  inline bool has_extra() const;
  inline void clear_extra();
  static const int kExtraFieldNumber = 5;
  inline const ::std::string& extra() const;
  inline void set_extra(const ::std::string& value);
  inline void set_extra(const char* value);
  inline void set_extra(const char* value, size_t size);
  inline ::std::string* mutable_extra();
  inline ::std::string* release_extra();
  inline void set_allocated_extra(::std::string* extra);

  // @@protoc_insertion_point(class_scope:common.UserLogin)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_channel();
  inline void clear_has_channel();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_extra();
  inline void clear_has_extra();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* user_id_;
  ::std::string* channel_;
  ::std::string* version_;
  ::std::string* token_;
  ::std::string* extra_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_MessageRouting_2eproto();
  friend void protobuf_AssignDesc_MessageRouting_2eproto();
  friend void protobuf_ShutdownFile_MessageRouting_2eproto();

  void InitAsDefaultInstance();
  static UserLogin* default_instance_;
};
// -------------------------------------------------------------------

class UserLoginResponse : public ::google::protobuf::Message {
 public:
  UserLoginResponse();
  virtual ~UserLoginResponse();

  UserLoginResponse(const UserLoginResponse& from);

  inline UserLoginResponse& operator=(const UserLoginResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserLoginResponse& default_instance();

  void Swap(UserLoginResponse* other);

  // implements Message ----------------------------------------------

  UserLoginResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserLoginResponse& from);
  void MergeFrom(const UserLoginResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline bool status() const;
  inline void set_status(bool value);

  // optional string extra = 2;
  inline bool has_extra() const;
  inline void clear_extra();
  static const int kExtraFieldNumber = 2;
  inline const ::std::string& extra() const;
  inline void set_extra(const ::std::string& value);
  inline void set_extra(const char* value);
  inline void set_extra(const char* value, size_t size);
  inline ::std::string* mutable_extra();
  inline ::std::string* release_extra();
  inline void set_allocated_extra(::std::string* extra);

  // @@protoc_insertion_point(class_scope:common.UserLoginResponse)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_extra();
  inline void clear_has_extra();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* extra_;
  bool status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_MessageRouting_2eproto();
  friend void protobuf_AssignDesc_MessageRouting_2eproto();
  friend void protobuf_ShutdownFile_MessageRouting_2eproto();

  void InitAsDefaultInstance();
  static UserLoginResponse* default_instance_;
};
// -------------------------------------------------------------------

class UserLogout : public ::google::protobuf::Message {
 public:
  UserLogout();
  virtual ~UserLogout();

  UserLogout(const UserLogout& from);

  inline UserLogout& operator=(const UserLogout& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserLogout& default_instance();

  void Swap(UserLogout* other);

  // implements Message ----------------------------------------------

  UserLogout* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserLogout& from);
  void MergeFrom(const UserLogout& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline const ::std::string& user_id() const;
  inline void set_user_id(const ::std::string& value);
  inline void set_user_id(const char* value);
  inline void set_user_id(const char* value, size_t size);
  inline ::std::string* mutable_user_id();
  inline ::std::string* release_user_id();
  inline void set_allocated_user_id(::std::string* user_id);

  // optional string extra = 2;
  inline bool has_extra() const;
  inline void clear_extra();
  static const int kExtraFieldNumber = 2;
  inline const ::std::string& extra() const;
  inline void set_extra(const ::std::string& value);
  inline void set_extra(const char* value);
  inline void set_extra(const char* value, size_t size);
  inline ::std::string* mutable_extra();
  inline ::std::string* release_extra();
  inline void set_allocated_extra(::std::string* extra);

  // @@protoc_insertion_point(class_scope:common.UserLogout)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_extra();
  inline void clear_has_extra();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* user_id_;
  ::std::string* extra_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_MessageRouting_2eproto();
  friend void protobuf_AssignDesc_MessageRouting_2eproto();
  friend void protobuf_ShutdownFile_MessageRouting_2eproto();

  void InitAsDefaultInstance();
  static UserLogout* default_instance_;
};
// -------------------------------------------------------------------

class UserLogoutResponse : public ::google::protobuf::Message {
 public:
  UserLogoutResponse();
  virtual ~UserLogoutResponse();

  UserLogoutResponse(const UserLogoutResponse& from);

  inline UserLogoutResponse& operator=(const UserLogoutResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserLogoutResponse& default_instance();

  void Swap(UserLogoutResponse* other);

  // implements Message ----------------------------------------------

  UserLogoutResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserLogoutResponse& from);
  void MergeFrom(const UserLogoutResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline bool status() const;
  inline void set_status(bool value);

  // optional string extra = 2;
  inline bool has_extra() const;
  inline void clear_extra();
  static const int kExtraFieldNumber = 2;
  inline const ::std::string& extra() const;
  inline void set_extra(const ::std::string& value);
  inline void set_extra(const char* value);
  inline void set_extra(const char* value, size_t size);
  inline ::std::string* mutable_extra();
  inline ::std::string* release_extra();
  inline void set_allocated_extra(::std::string* extra);

  // @@protoc_insertion_point(class_scope:common.UserLogoutResponse)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_extra();
  inline void clear_has_extra();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* extra_;
  bool status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_MessageRouting_2eproto();
  friend void protobuf_AssignDesc_MessageRouting_2eproto();
  friend void protobuf_ShutdownFile_MessageRouting_2eproto();

  void InitAsDefaultInstance();
  static UserLogoutResponse* default_instance_;
};
// -------------------------------------------------------------------

class Message : public ::google::protobuf::Message {
 public:
  Message();
  virtual ~Message();

  Message(const Message& from);

  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Message& default_instance();

  void Swap(Message* other);

  // implements Message ----------------------------------------------

  Message* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Message& from);
  void MergeFrom(const Message& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline const ::std::string& message_id() const;
  inline void set_message_id(const ::std::string& value);
  inline void set_message_id(const char* value);
  inline void set_message_id(const char* value, size_t size);
  inline ::std::string* mutable_message_id();
  inline ::std::string* release_message_id();
  inline void set_allocated_message_id(::std::string* message_id);

  // required string sender = 2;
  inline bool has_sender() const;
  inline void clear_sender();
  static const int kSenderFieldNumber = 2;
  inline const ::std::string& sender() const;
  inline void set_sender(const ::std::string& value);
  inline void set_sender(const char* value);
  inline void set_sender(const char* value, size_t size);
  inline ::std::string* mutable_sender();
  inline ::std::string* release_sender();
  inline void set_allocated_sender(::std::string* sender);

  // required string receiver = 3;
  inline bool has_receiver() const;
  inline void clear_receiver();
  static const int kReceiverFieldNumber = 3;
  inline const ::std::string& receiver() const;
  inline void set_receiver(const ::std::string& value);
  inline void set_receiver(const char* value);
  inline void set_receiver(const char* value, size_t size);
  inline ::std::string* mutable_receiver();
  inline ::std::string* release_receiver();
  inline void set_allocated_receiver(::std::string* receiver);

  // required string message_body = 4;
  inline bool has_message_body() const;
  inline void clear_message_body();
  static const int kMessageBodyFieldNumber = 4;
  inline const ::std::string& message_body() const;
  inline void set_message_body(const ::std::string& value);
  inline void set_message_body(const char* value);
  inline void set_message_body(const char* value, size_t size);
  inline ::std::string* mutable_message_body();
  inline ::std::string* release_message_body();
  inline void set_allocated_message_body(::std::string* message_body);

  // optional int64 date = 5;
  inline bool has_date() const;
  inline void clear_date();
  static const int kDateFieldNumber = 5;
  inline ::google::protobuf::int64 date() const;
  inline void set_date(::google::protobuf::int64 value);

  // optional string extra = 6;
  inline bool has_extra() const;
  inline void clear_extra();
  static const int kExtraFieldNumber = 6;
  inline const ::std::string& extra() const;
  inline void set_extra(const ::std::string& value);
  inline void set_extra(const char* value);
  inline void set_extra(const char* value, size_t size);
  inline ::std::string* mutable_extra();
  inline ::std::string* release_extra();
  inline void set_allocated_extra(::std::string* extra);

  // @@protoc_insertion_point(class_scope:common.Message)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_sender();
  inline void clear_has_sender();
  inline void set_has_receiver();
  inline void clear_has_receiver();
  inline void set_has_message_body();
  inline void clear_has_message_body();
  inline void set_has_date();
  inline void clear_has_date();
  inline void set_has_extra();
  inline void clear_has_extra();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* message_id_;
  ::std::string* sender_;
  ::std::string* receiver_;
  ::std::string* message_body_;
  ::google::protobuf::int64 date_;
  ::std::string* extra_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_MessageRouting_2eproto();
  friend void protobuf_AssignDesc_MessageRouting_2eproto();
  friend void protobuf_ShutdownFile_MessageRouting_2eproto();

  void InitAsDefaultInstance();
  static Message* default_instance_;
};
// -------------------------------------------------------------------

class MessageResponse : public ::google::protobuf::Message {
 public:
  MessageResponse();
  virtual ~MessageResponse();

  MessageResponse(const MessageResponse& from);

  inline MessageResponse& operator=(const MessageResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MessageResponse& default_instance();

  void Swap(MessageResponse* other);

  // implements Message ----------------------------------------------

  MessageResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MessageResponse& from);
  void MergeFrom(const MessageResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline const ::std::string& message_id() const;
  inline void set_message_id(const ::std::string& value);
  inline void set_message_id(const char* value);
  inline void set_message_id(const char* value, size_t size);
  inline ::std::string* mutable_message_id();
  inline ::std::string* release_message_id();
  inline void set_allocated_message_id(::std::string* message_id);

  // required bool status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline bool status() const;
  inline void set_status(bool value);

  // optional string extra = 3;
  inline bool has_extra() const;
  inline void clear_extra();
  static const int kExtraFieldNumber = 3;
  inline const ::std::string& extra() const;
  inline void set_extra(const ::std::string& value);
  inline void set_extra(const char* value);
  inline void set_extra(const char* value, size_t size);
  inline ::std::string* mutable_extra();
  inline ::std::string* release_extra();
  inline void set_allocated_extra(::std::string* extra);

  // @@protoc_insertion_point(class_scope:common.MessageResponse)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_extra();
  inline void clear_has_extra();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* message_id_;
  ::std::string* extra_;
  bool status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_MessageRouting_2eproto();
  friend void protobuf_AssignDesc_MessageRouting_2eproto();
  friend void protobuf_ShutdownFile_MessageRouting_2eproto();

  void InitAsDefaultInstance();
  static MessageResponse* default_instance_;
};
// -------------------------------------------------------------------

class ReceiveMessageAck : public ::google::protobuf::Message {
 public:
  ReceiveMessageAck();
  virtual ~ReceiveMessageAck();

  ReceiveMessageAck(const ReceiveMessageAck& from);

  inline ReceiveMessageAck& operator=(const ReceiveMessageAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReceiveMessageAck& default_instance();

  void Swap(ReceiveMessageAck* other);

  // implements Message ----------------------------------------------

  ReceiveMessageAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReceiveMessageAck& from);
  void MergeFrom(const ReceiveMessageAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline const ::std::string& message_id() const;
  inline void set_message_id(const ::std::string& value);
  inline void set_message_id(const char* value);
  inline void set_message_id(const char* value, size_t size);
  inline ::std::string* mutable_message_id();
  inline ::std::string* release_message_id();
  inline void set_allocated_message_id(::std::string* message_id);

  // required int32 status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);

  // optional string extra = 3;
  inline bool has_extra() const;
  inline void clear_extra();
  static const int kExtraFieldNumber = 3;
  inline const ::std::string& extra() const;
  inline void set_extra(const ::std::string& value);
  inline void set_extra(const char* value);
  inline void set_extra(const char* value, size_t size);
  inline ::std::string* mutable_extra();
  inline ::std::string* release_extra();
  inline void set_allocated_extra(::std::string* extra);

  // @@protoc_insertion_point(class_scope:common.ReceiveMessageAck)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_extra();
  inline void clear_has_extra();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* message_id_;
  ::std::string* extra_;
  ::google::protobuf::int32 status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_MessageRouting_2eproto();
  friend void protobuf_AssignDesc_MessageRouting_2eproto();
  friend void protobuf_ShutdownFile_MessageRouting_2eproto();

  void InitAsDefaultInstance();
  static ReceiveMessageAck* default_instance_;
};
// -------------------------------------------------------------------

class NormalMessage : public ::google::protobuf::Message {
 public:
  NormalMessage();
  virtual ~NormalMessage();

  NormalMessage(const NormalMessage& from);

  inline NormalMessage& operator=(const NormalMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NormalMessage& default_instance();

  void Swap(NormalMessage* other);

  // implements Message ----------------------------------------------

  NormalMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NormalMessage& from);
  void MergeFrom(const NormalMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline const ::std::string& message_id() const;
  inline void set_message_id(const ::std::string& value);
  inline void set_message_id(const char* value);
  inline void set_message_id(const char* value, size_t size);
  inline ::std::string* mutable_message_id();
  inline ::std::string* release_message_id();
  inline void set_allocated_message_id(::std::string* message_id);

  // required string receiver = 2;
  inline bool has_receiver() const;
  inline void clear_receiver();
  static const int kReceiverFieldNumber = 2;
  inline const ::std::string& receiver() const;
  inline void set_receiver(const ::std::string& value);
  inline void set_receiver(const char* value);
  inline void set_receiver(const char* value, size_t size);
  inline ::std::string* mutable_receiver();
  inline ::std::string* release_receiver();
  inline void set_allocated_receiver(::std::string* receiver);

  // required bytes content = 3;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 3;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const void* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // required int64 date = 4;
  inline bool has_date() const;
  inline void clear_date();
  static const int kDateFieldNumber = 4;
  inline ::google::protobuf::int64 date() const;
  inline void set_date(::google::protobuf::int64 value);

  // optional int32 expire = 5;
  inline bool has_expire() const;
  inline void clear_expire();
  static const int kExpireFieldNumber = 5;
  inline ::google::protobuf::int32 expire() const;
  inline void set_expire(::google::protobuf::int32 value);

  // optional string extra = 6;
  inline bool has_extra() const;
  inline void clear_extra();
  static const int kExtraFieldNumber = 6;
  inline const ::std::string& extra() const;
  inline void set_extra(const ::std::string& value);
  inline void set_extra(const char* value);
  inline void set_extra(const char* value, size_t size);
  inline ::std::string* mutable_extra();
  inline ::std::string* release_extra();
  inline void set_allocated_extra(::std::string* extra);

  // @@protoc_insertion_point(class_scope:common.NormalMessage)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_receiver();
  inline void clear_has_receiver();
  inline void set_has_content();
  inline void clear_has_content();
  inline void set_has_date();
  inline void clear_has_date();
  inline void set_has_expire();
  inline void clear_has_expire();
  inline void set_has_extra();
  inline void clear_has_extra();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* message_id_;
  ::std::string* receiver_;
  ::std::string* content_;
  ::google::protobuf::int64 date_;
  ::std::string* extra_;
  ::google::protobuf::int32 expire_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_MessageRouting_2eproto();
  friend void protobuf_AssignDesc_MessageRouting_2eproto();
  friend void protobuf_ShutdownFile_MessageRouting_2eproto();

  void InitAsDefaultInstance();
  static NormalMessage* default_instance_;
};
// -------------------------------------------------------------------

class NormalMessageAck : public ::google::protobuf::Message {
 public:
  NormalMessageAck();
  virtual ~NormalMessageAck();

  NormalMessageAck(const NormalMessageAck& from);

  inline NormalMessageAck& operator=(const NormalMessageAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NormalMessageAck& default_instance();

  void Swap(NormalMessageAck* other);

  // implements Message ----------------------------------------------

  NormalMessageAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NormalMessageAck& from);
  void MergeFrom(const NormalMessageAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline const ::std::string& message_id() const;
  inline void set_message_id(const ::std::string& value);
  inline void set_message_id(const char* value);
  inline void set_message_id(const char* value, size_t size);
  inline ::std::string* mutable_message_id();
  inline ::std::string* release_message_id();
  inline void set_allocated_message_id(::std::string* message_id);

  // required int32 status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);

  // optional string extra = 3;
  inline bool has_extra() const;
  inline void clear_extra();
  static const int kExtraFieldNumber = 3;
  inline const ::std::string& extra() const;
  inline void set_extra(const ::std::string& value);
  inline void set_extra(const char* value);
  inline void set_extra(const char* value, size_t size);
  inline ::std::string* mutable_extra();
  inline ::std::string* release_extra();
  inline void set_allocated_extra(::std::string* extra);

  // @@protoc_insertion_point(class_scope:common.NormalMessageAck)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_extra();
  inline void clear_has_extra();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* message_id_;
  ::std::string* extra_;
  ::google::protobuf::int32 status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_MessageRouting_2eproto();
  friend void protobuf_AssignDesc_MessageRouting_2eproto();
  friend void protobuf_ShutdownFile_MessageRouting_2eproto();

  void InitAsDefaultInstance();
  static NormalMessageAck* default_instance_;
};
// ===================================================================


// ===================================================================

// HeartbeatInit

// required int32 last_timeout = 1;
inline bool HeartbeatInit::has_last_timeout() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HeartbeatInit::set_has_last_timeout() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HeartbeatInit::clear_has_last_timeout() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HeartbeatInit::clear_last_timeout() {
  last_timeout_ = 0;
  clear_has_last_timeout();
}
inline ::google::protobuf::int32 HeartbeatInit::last_timeout() const {
  return last_timeout_;
}
inline void HeartbeatInit::set_last_timeout(::google::protobuf::int32 value) {
  set_has_last_timeout();
  last_timeout_ = value;
}

// optional string extra = 2;
inline bool HeartbeatInit::has_extra() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HeartbeatInit::set_has_extra() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HeartbeatInit::clear_has_extra() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HeartbeatInit::clear_extra() {
  if (extra_ != &::google::protobuf::internal::kEmptyString) {
    extra_->clear();
  }
  clear_has_extra();
}
inline const ::std::string& HeartbeatInit::extra() const {
  return *extra_;
}
inline void HeartbeatInit::set_extra(const ::std::string& value) {
  set_has_extra();
  if (extra_ == &::google::protobuf::internal::kEmptyString) {
    extra_ = new ::std::string;
  }
  extra_->assign(value);
}
inline void HeartbeatInit::set_extra(const char* value) {
  set_has_extra();
  if (extra_ == &::google::protobuf::internal::kEmptyString) {
    extra_ = new ::std::string;
  }
  extra_->assign(value);
}
inline void HeartbeatInit::set_extra(const char* value, size_t size) {
  set_has_extra();
  if (extra_ == &::google::protobuf::internal::kEmptyString) {
    extra_ = new ::std::string;
  }
  extra_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HeartbeatInit::mutable_extra() {
  set_has_extra();
  if (extra_ == &::google::protobuf::internal::kEmptyString) {
    extra_ = new ::std::string;
  }
  return extra_;
}
inline ::std::string* HeartbeatInit::release_extra() {
  clear_has_extra();
  if (extra_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = extra_;
    extra_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void HeartbeatInit::set_allocated_extra(::std::string* extra) {
  if (extra_ != &::google::protobuf::internal::kEmptyString) {
    delete extra_;
  }
  if (extra) {
    set_has_extra();
    extra_ = extra;
  } else {
    clear_has_extra();
    extra_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// HeartbeatInitResponse

// optional int32 next_heartbeat = 1;
inline bool HeartbeatInitResponse::has_next_heartbeat() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HeartbeatInitResponse::set_has_next_heartbeat() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HeartbeatInitResponse::clear_has_next_heartbeat() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HeartbeatInitResponse::clear_next_heartbeat() {
  next_heartbeat_ = 0;
  clear_has_next_heartbeat();
}
inline ::google::protobuf::int32 HeartbeatInitResponse::next_heartbeat() const {
  return next_heartbeat_;
}
inline void HeartbeatInitResponse::set_next_heartbeat(::google::protobuf::int32 value) {
  set_has_next_heartbeat();
  next_heartbeat_ = value;
}

// optional string extra = 2;
inline bool HeartbeatInitResponse::has_extra() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HeartbeatInitResponse::set_has_extra() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HeartbeatInitResponse::clear_has_extra() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HeartbeatInitResponse::clear_extra() {
  if (extra_ != &::google::protobuf::internal::kEmptyString) {
    extra_->clear();
  }
  clear_has_extra();
}
inline const ::std::string& HeartbeatInitResponse::extra() const {
  return *extra_;
}
inline void HeartbeatInitResponse::set_extra(const ::std::string& value) {
  set_has_extra();
  if (extra_ == &::google::protobuf::internal::kEmptyString) {
    extra_ = new ::std::string;
  }
  extra_->assign(value);
}
inline void HeartbeatInitResponse::set_extra(const char* value) {
  set_has_extra();
  if (extra_ == &::google::protobuf::internal::kEmptyString) {
    extra_ = new ::std::string;
  }
  extra_->assign(value);
}
inline void HeartbeatInitResponse::set_extra(const char* value, size_t size) {
  set_has_extra();
  if (extra_ == &::google::protobuf::internal::kEmptyString) {
    extra_ = new ::std::string;
  }
  extra_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HeartbeatInitResponse::mutable_extra() {
  set_has_extra();
  if (extra_ == &::google::protobuf::internal::kEmptyString) {
    extra_ = new ::std::string;
  }
  return extra_;
}
inline ::std::string* HeartbeatInitResponse::release_extra() {
  clear_has_extra();
  if (extra_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = extra_;
    extra_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void HeartbeatInitResponse::set_allocated_extra(::std::string* extra) {
  if (extra_ != &::google::protobuf::internal::kEmptyString) {
    delete extra_;
  }
  if (extra) {
    set_has_extra();
    extra_ = extra;
  } else {
    clear_has_extra();
    extra_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Heartbeat

// optional int32 last_delay = 1;
inline bool Heartbeat::has_last_delay() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Heartbeat::set_has_last_delay() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Heartbeat::clear_has_last_delay() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Heartbeat::clear_last_delay() {
  last_delay_ = 0;
  clear_has_last_delay();
}
inline ::google::protobuf::int32 Heartbeat::last_delay() const {
  return last_delay_;
}
inline void Heartbeat::set_last_delay(::google::protobuf::int32 value) {
  set_has_last_delay();
  last_delay_ = value;
}

// optional string extra = 2;
inline bool Heartbeat::has_extra() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Heartbeat::set_has_extra() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Heartbeat::clear_has_extra() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Heartbeat::clear_extra() {
  if (extra_ != &::google::protobuf::internal::kEmptyString) {
    extra_->clear();
  }
  clear_has_extra();
}
inline const ::std::string& Heartbeat::extra() const {
  return *extra_;
}
inline void Heartbeat::set_extra(const ::std::string& value) {
  set_has_extra();
  if (extra_ == &::google::protobuf::internal::kEmptyString) {
    extra_ = new ::std::string;
  }
  extra_->assign(value);
}
inline void Heartbeat::set_extra(const char* value) {
  set_has_extra();
  if (extra_ == &::google::protobuf::internal::kEmptyString) {
    extra_ = new ::std::string;
  }
  extra_->assign(value);
}
inline void Heartbeat::set_extra(const char* value, size_t size) {
  set_has_extra();
  if (extra_ == &::google::protobuf::internal::kEmptyString) {
    extra_ = new ::std::string;
  }
  extra_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Heartbeat::mutable_extra() {
  set_has_extra();
  if (extra_ == &::google::protobuf::internal::kEmptyString) {
    extra_ = new ::std::string;
  }
  return extra_;
}
inline ::std::string* Heartbeat::release_extra() {
  clear_has_extra();
  if (extra_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = extra_;
    extra_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Heartbeat::set_allocated_extra(::std::string* extra) {
  if (extra_ != &::google::protobuf::internal::kEmptyString) {
    delete extra_;
  }
  if (extra) {
    set_has_extra();
    extra_ = extra;
  } else {
    clear_has_extra();
    extra_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// HeartbeatResponse

// optional int32 next_heartbeat = 1;
inline bool HeartbeatResponse::has_next_heartbeat() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HeartbeatResponse::set_has_next_heartbeat() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HeartbeatResponse::clear_has_next_heartbeat() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HeartbeatResponse::clear_next_heartbeat() {
  next_heartbeat_ = 0;
  clear_has_next_heartbeat();
}
inline ::google::protobuf::int32 HeartbeatResponse::next_heartbeat() const {
  return next_heartbeat_;
}
inline void HeartbeatResponse::set_next_heartbeat(::google::protobuf::int32 value) {
  set_has_next_heartbeat();
  next_heartbeat_ = value;
}

// optional string extra = 2;
inline bool HeartbeatResponse::has_extra() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HeartbeatResponse::set_has_extra() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HeartbeatResponse::clear_has_extra() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HeartbeatResponse::clear_extra() {
  if (extra_ != &::google::protobuf::internal::kEmptyString) {
    extra_->clear();
  }
  clear_has_extra();
}
inline const ::std::string& HeartbeatResponse::extra() const {
  return *extra_;
}
inline void HeartbeatResponse::set_extra(const ::std::string& value) {
  set_has_extra();
  if (extra_ == &::google::protobuf::internal::kEmptyString) {
    extra_ = new ::std::string;
  }
  extra_->assign(value);
}
inline void HeartbeatResponse::set_extra(const char* value) {
  set_has_extra();
  if (extra_ == &::google::protobuf::internal::kEmptyString) {
    extra_ = new ::std::string;
  }
  extra_->assign(value);
}
inline void HeartbeatResponse::set_extra(const char* value, size_t size) {
  set_has_extra();
  if (extra_ == &::google::protobuf::internal::kEmptyString) {
    extra_ = new ::std::string;
  }
  extra_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HeartbeatResponse::mutable_extra() {
  set_has_extra();
  if (extra_ == &::google::protobuf::internal::kEmptyString) {
    extra_ = new ::std::string;
  }
  return extra_;
}
inline ::std::string* HeartbeatResponse::release_extra() {
  clear_has_extra();
  if (extra_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = extra_;
    extra_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void HeartbeatResponse::set_allocated_extra(::std::string* extra) {
  if (extra_ != &::google::protobuf::internal::kEmptyString) {
    delete extra_;
  }
  if (extra) {
    set_has_extra();
    extra_ = extra;
  } else {
    clear_has_extra();
    extra_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UserLogin

// required string user_id = 1;
inline bool UserLogin::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserLogin::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserLogin::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserLogin::clear_user_id() {
  if (user_id_ != &::google::protobuf::internal::kEmptyString) {
    user_id_->clear();
  }
  clear_has_user_id();
}
inline const ::std::string& UserLogin::user_id() const {
  return *user_id_;
}
inline void UserLogin::set_user_id(const ::std::string& value) {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(value);
}
inline void UserLogin::set_user_id(const char* value) {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(value);
}
inline void UserLogin::set_user_id(const char* value, size_t size) {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserLogin::mutable_user_id() {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    user_id_ = new ::std::string;
  }
  return user_id_;
}
inline ::std::string* UserLogin::release_user_id() {
  clear_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_id_;
    user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserLogin::set_allocated_user_id(::std::string* user_id) {
  if (user_id_ != &::google::protobuf::internal::kEmptyString) {
    delete user_id_;
  }
  if (user_id) {
    set_has_user_id();
    user_id_ = user_id;
  } else {
    clear_has_user_id();
    user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string channel = 2;
inline bool UserLogin::has_channel() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserLogin::set_has_channel() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserLogin::clear_has_channel() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserLogin::clear_channel() {
  if (channel_ != &::google::protobuf::internal::kEmptyString) {
    channel_->clear();
  }
  clear_has_channel();
}
inline const ::std::string& UserLogin::channel() const {
  return *channel_;
}
inline void UserLogin::set_channel(const ::std::string& value) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  channel_->assign(value);
}
inline void UserLogin::set_channel(const char* value) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  channel_->assign(value);
}
inline void UserLogin::set_channel(const char* value, size_t size) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  channel_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserLogin::mutable_channel() {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  return channel_;
}
inline ::std::string* UserLogin::release_channel() {
  clear_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = channel_;
    channel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserLogin::set_allocated_channel(::std::string* channel) {
  if (channel_ != &::google::protobuf::internal::kEmptyString) {
    delete channel_;
  }
  if (channel) {
    set_has_channel();
    channel_ = channel;
  } else {
    clear_has_channel();
    channel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string version = 3;
inline bool UserLogin::has_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserLogin::set_has_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserLogin::clear_has_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserLogin::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& UserLogin::version() const {
  return *version_;
}
inline void UserLogin::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void UserLogin::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void UserLogin::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserLogin::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* UserLogin::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserLogin::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string token = 4;
inline bool UserLogin::has_token() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserLogin::set_has_token() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserLogin::clear_has_token() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserLogin::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& UserLogin::token() const {
  return *token_;
}
inline void UserLogin::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void UserLogin::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void UserLogin::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserLogin::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* UserLogin::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserLogin::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string extra = 5;
inline bool UserLogin::has_extra() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserLogin::set_has_extra() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserLogin::clear_has_extra() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserLogin::clear_extra() {
  if (extra_ != &::google::protobuf::internal::kEmptyString) {
    extra_->clear();
  }
  clear_has_extra();
}
inline const ::std::string& UserLogin::extra() const {
  return *extra_;
}
inline void UserLogin::set_extra(const ::std::string& value) {
  set_has_extra();
  if (extra_ == &::google::protobuf::internal::kEmptyString) {
    extra_ = new ::std::string;
  }
  extra_->assign(value);
}
inline void UserLogin::set_extra(const char* value) {
  set_has_extra();
  if (extra_ == &::google::protobuf::internal::kEmptyString) {
    extra_ = new ::std::string;
  }
  extra_->assign(value);
}
inline void UserLogin::set_extra(const char* value, size_t size) {
  set_has_extra();
  if (extra_ == &::google::protobuf::internal::kEmptyString) {
    extra_ = new ::std::string;
  }
  extra_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserLogin::mutable_extra() {
  set_has_extra();
  if (extra_ == &::google::protobuf::internal::kEmptyString) {
    extra_ = new ::std::string;
  }
  return extra_;
}
inline ::std::string* UserLogin::release_extra() {
  clear_has_extra();
  if (extra_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = extra_;
    extra_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserLogin::set_allocated_extra(::std::string* extra) {
  if (extra_ != &::google::protobuf::internal::kEmptyString) {
    delete extra_;
  }
  if (extra) {
    set_has_extra();
    extra_ = extra;
  } else {
    clear_has_extra();
    extra_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UserLoginResponse

// required bool status = 1;
inline bool UserLoginResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserLoginResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserLoginResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserLoginResponse::clear_status() {
  status_ = false;
  clear_has_status();
}
inline bool UserLoginResponse::status() const {
  return status_;
}
inline void UserLoginResponse::set_status(bool value) {
  set_has_status();
  status_ = value;
}

// optional string extra = 2;
inline bool UserLoginResponse::has_extra() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserLoginResponse::set_has_extra() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserLoginResponse::clear_has_extra() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserLoginResponse::clear_extra() {
  if (extra_ != &::google::protobuf::internal::kEmptyString) {
    extra_->clear();
  }
  clear_has_extra();
}
inline const ::std::string& UserLoginResponse::extra() const {
  return *extra_;
}
inline void UserLoginResponse::set_extra(const ::std::string& value) {
  set_has_extra();
  if (extra_ == &::google::protobuf::internal::kEmptyString) {
    extra_ = new ::std::string;
  }
  extra_->assign(value);
}
inline void UserLoginResponse::set_extra(const char* value) {
  set_has_extra();
  if (extra_ == &::google::protobuf::internal::kEmptyString) {
    extra_ = new ::std::string;
  }
  extra_->assign(value);
}
inline void UserLoginResponse::set_extra(const char* value, size_t size) {
  set_has_extra();
  if (extra_ == &::google::protobuf::internal::kEmptyString) {
    extra_ = new ::std::string;
  }
  extra_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserLoginResponse::mutable_extra() {
  set_has_extra();
  if (extra_ == &::google::protobuf::internal::kEmptyString) {
    extra_ = new ::std::string;
  }
  return extra_;
}
inline ::std::string* UserLoginResponse::release_extra() {
  clear_has_extra();
  if (extra_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = extra_;
    extra_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserLoginResponse::set_allocated_extra(::std::string* extra) {
  if (extra_ != &::google::protobuf::internal::kEmptyString) {
    delete extra_;
  }
  if (extra) {
    set_has_extra();
    extra_ = extra;
  } else {
    clear_has_extra();
    extra_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UserLogout

// required string user_id = 1;
inline bool UserLogout::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserLogout::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserLogout::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserLogout::clear_user_id() {
  if (user_id_ != &::google::protobuf::internal::kEmptyString) {
    user_id_->clear();
  }
  clear_has_user_id();
}
inline const ::std::string& UserLogout::user_id() const {
  return *user_id_;
}
inline void UserLogout::set_user_id(const ::std::string& value) {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(value);
}
inline void UserLogout::set_user_id(const char* value) {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(value);
}
inline void UserLogout::set_user_id(const char* value, size_t size) {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserLogout::mutable_user_id() {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    user_id_ = new ::std::string;
  }
  return user_id_;
}
inline ::std::string* UserLogout::release_user_id() {
  clear_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_id_;
    user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserLogout::set_allocated_user_id(::std::string* user_id) {
  if (user_id_ != &::google::protobuf::internal::kEmptyString) {
    delete user_id_;
  }
  if (user_id) {
    set_has_user_id();
    user_id_ = user_id;
  } else {
    clear_has_user_id();
    user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string extra = 2;
inline bool UserLogout::has_extra() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserLogout::set_has_extra() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserLogout::clear_has_extra() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserLogout::clear_extra() {
  if (extra_ != &::google::protobuf::internal::kEmptyString) {
    extra_->clear();
  }
  clear_has_extra();
}
inline const ::std::string& UserLogout::extra() const {
  return *extra_;
}
inline void UserLogout::set_extra(const ::std::string& value) {
  set_has_extra();
  if (extra_ == &::google::protobuf::internal::kEmptyString) {
    extra_ = new ::std::string;
  }
  extra_->assign(value);
}
inline void UserLogout::set_extra(const char* value) {
  set_has_extra();
  if (extra_ == &::google::protobuf::internal::kEmptyString) {
    extra_ = new ::std::string;
  }
  extra_->assign(value);
}
inline void UserLogout::set_extra(const char* value, size_t size) {
  set_has_extra();
  if (extra_ == &::google::protobuf::internal::kEmptyString) {
    extra_ = new ::std::string;
  }
  extra_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserLogout::mutable_extra() {
  set_has_extra();
  if (extra_ == &::google::protobuf::internal::kEmptyString) {
    extra_ = new ::std::string;
  }
  return extra_;
}
inline ::std::string* UserLogout::release_extra() {
  clear_has_extra();
  if (extra_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = extra_;
    extra_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserLogout::set_allocated_extra(::std::string* extra) {
  if (extra_ != &::google::protobuf::internal::kEmptyString) {
    delete extra_;
  }
  if (extra) {
    set_has_extra();
    extra_ = extra;
  } else {
    clear_has_extra();
    extra_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UserLogoutResponse

// required bool status = 1;
inline bool UserLogoutResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserLogoutResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserLogoutResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserLogoutResponse::clear_status() {
  status_ = false;
  clear_has_status();
}
inline bool UserLogoutResponse::status() const {
  return status_;
}
inline void UserLogoutResponse::set_status(bool value) {
  set_has_status();
  status_ = value;
}

// optional string extra = 2;
inline bool UserLogoutResponse::has_extra() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserLogoutResponse::set_has_extra() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserLogoutResponse::clear_has_extra() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserLogoutResponse::clear_extra() {
  if (extra_ != &::google::protobuf::internal::kEmptyString) {
    extra_->clear();
  }
  clear_has_extra();
}
inline const ::std::string& UserLogoutResponse::extra() const {
  return *extra_;
}
inline void UserLogoutResponse::set_extra(const ::std::string& value) {
  set_has_extra();
  if (extra_ == &::google::protobuf::internal::kEmptyString) {
    extra_ = new ::std::string;
  }
  extra_->assign(value);
}
inline void UserLogoutResponse::set_extra(const char* value) {
  set_has_extra();
  if (extra_ == &::google::protobuf::internal::kEmptyString) {
    extra_ = new ::std::string;
  }
  extra_->assign(value);
}
inline void UserLogoutResponse::set_extra(const char* value, size_t size) {
  set_has_extra();
  if (extra_ == &::google::protobuf::internal::kEmptyString) {
    extra_ = new ::std::string;
  }
  extra_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserLogoutResponse::mutable_extra() {
  set_has_extra();
  if (extra_ == &::google::protobuf::internal::kEmptyString) {
    extra_ = new ::std::string;
  }
  return extra_;
}
inline ::std::string* UserLogoutResponse::release_extra() {
  clear_has_extra();
  if (extra_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = extra_;
    extra_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserLogoutResponse::set_allocated_extra(::std::string* extra) {
  if (extra_ != &::google::protobuf::internal::kEmptyString) {
    delete extra_;
  }
  if (extra) {
    set_has_extra();
    extra_ = extra;
  } else {
    clear_has_extra();
    extra_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Message

// required string message_id = 1;
inline bool Message::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Message::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Message::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Message::clear_message_id() {
  if (message_id_ != &::google::protobuf::internal::kEmptyString) {
    message_id_->clear();
  }
  clear_has_message_id();
}
inline const ::std::string& Message::message_id() const {
  return *message_id_;
}
inline void Message::set_message_id(const ::std::string& value) {
  set_has_message_id();
  if (message_id_ == &::google::protobuf::internal::kEmptyString) {
    message_id_ = new ::std::string;
  }
  message_id_->assign(value);
}
inline void Message::set_message_id(const char* value) {
  set_has_message_id();
  if (message_id_ == &::google::protobuf::internal::kEmptyString) {
    message_id_ = new ::std::string;
  }
  message_id_->assign(value);
}
inline void Message::set_message_id(const char* value, size_t size) {
  set_has_message_id();
  if (message_id_ == &::google::protobuf::internal::kEmptyString) {
    message_id_ = new ::std::string;
  }
  message_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Message::mutable_message_id() {
  set_has_message_id();
  if (message_id_ == &::google::protobuf::internal::kEmptyString) {
    message_id_ = new ::std::string;
  }
  return message_id_;
}
inline ::std::string* Message::release_message_id() {
  clear_has_message_id();
  if (message_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = message_id_;
    message_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Message::set_allocated_message_id(::std::string* message_id) {
  if (message_id_ != &::google::protobuf::internal::kEmptyString) {
    delete message_id_;
  }
  if (message_id) {
    set_has_message_id();
    message_id_ = message_id;
  } else {
    clear_has_message_id();
    message_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string sender = 2;
inline bool Message::has_sender() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Message::set_has_sender() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Message::clear_has_sender() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Message::clear_sender() {
  if (sender_ != &::google::protobuf::internal::kEmptyString) {
    sender_->clear();
  }
  clear_has_sender();
}
inline const ::std::string& Message::sender() const {
  return *sender_;
}
inline void Message::set_sender(const ::std::string& value) {
  set_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    sender_ = new ::std::string;
  }
  sender_->assign(value);
}
inline void Message::set_sender(const char* value) {
  set_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    sender_ = new ::std::string;
  }
  sender_->assign(value);
}
inline void Message::set_sender(const char* value, size_t size) {
  set_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    sender_ = new ::std::string;
  }
  sender_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Message::mutable_sender() {
  set_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    sender_ = new ::std::string;
  }
  return sender_;
}
inline ::std::string* Message::release_sender() {
  clear_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sender_;
    sender_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Message::set_allocated_sender(::std::string* sender) {
  if (sender_ != &::google::protobuf::internal::kEmptyString) {
    delete sender_;
  }
  if (sender) {
    set_has_sender();
    sender_ = sender;
  } else {
    clear_has_sender();
    sender_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string receiver = 3;
inline bool Message::has_receiver() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Message::set_has_receiver() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Message::clear_has_receiver() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Message::clear_receiver() {
  if (receiver_ != &::google::protobuf::internal::kEmptyString) {
    receiver_->clear();
  }
  clear_has_receiver();
}
inline const ::std::string& Message::receiver() const {
  return *receiver_;
}
inline void Message::set_receiver(const ::std::string& value) {
  set_has_receiver();
  if (receiver_ == &::google::protobuf::internal::kEmptyString) {
    receiver_ = new ::std::string;
  }
  receiver_->assign(value);
}
inline void Message::set_receiver(const char* value) {
  set_has_receiver();
  if (receiver_ == &::google::protobuf::internal::kEmptyString) {
    receiver_ = new ::std::string;
  }
  receiver_->assign(value);
}
inline void Message::set_receiver(const char* value, size_t size) {
  set_has_receiver();
  if (receiver_ == &::google::protobuf::internal::kEmptyString) {
    receiver_ = new ::std::string;
  }
  receiver_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Message::mutable_receiver() {
  set_has_receiver();
  if (receiver_ == &::google::protobuf::internal::kEmptyString) {
    receiver_ = new ::std::string;
  }
  return receiver_;
}
inline ::std::string* Message::release_receiver() {
  clear_has_receiver();
  if (receiver_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = receiver_;
    receiver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Message::set_allocated_receiver(::std::string* receiver) {
  if (receiver_ != &::google::protobuf::internal::kEmptyString) {
    delete receiver_;
  }
  if (receiver) {
    set_has_receiver();
    receiver_ = receiver;
  } else {
    clear_has_receiver();
    receiver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string message_body = 4;
inline bool Message::has_message_body() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Message::set_has_message_body() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Message::clear_has_message_body() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Message::clear_message_body() {
  if (message_body_ != &::google::protobuf::internal::kEmptyString) {
    message_body_->clear();
  }
  clear_has_message_body();
}
inline const ::std::string& Message::message_body() const {
  return *message_body_;
}
inline void Message::set_message_body(const ::std::string& value) {
  set_has_message_body();
  if (message_body_ == &::google::protobuf::internal::kEmptyString) {
    message_body_ = new ::std::string;
  }
  message_body_->assign(value);
}
inline void Message::set_message_body(const char* value) {
  set_has_message_body();
  if (message_body_ == &::google::protobuf::internal::kEmptyString) {
    message_body_ = new ::std::string;
  }
  message_body_->assign(value);
}
inline void Message::set_message_body(const char* value, size_t size) {
  set_has_message_body();
  if (message_body_ == &::google::protobuf::internal::kEmptyString) {
    message_body_ = new ::std::string;
  }
  message_body_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Message::mutable_message_body() {
  set_has_message_body();
  if (message_body_ == &::google::protobuf::internal::kEmptyString) {
    message_body_ = new ::std::string;
  }
  return message_body_;
}
inline ::std::string* Message::release_message_body() {
  clear_has_message_body();
  if (message_body_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = message_body_;
    message_body_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Message::set_allocated_message_body(::std::string* message_body) {
  if (message_body_ != &::google::protobuf::internal::kEmptyString) {
    delete message_body_;
  }
  if (message_body) {
    set_has_message_body();
    message_body_ = message_body;
  } else {
    clear_has_message_body();
    message_body_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 date = 5;
inline bool Message::has_date() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Message::set_has_date() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Message::clear_has_date() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Message::clear_date() {
  date_ = GOOGLE_LONGLONG(0);
  clear_has_date();
}
inline ::google::protobuf::int64 Message::date() const {
  return date_;
}
inline void Message::set_date(::google::protobuf::int64 value) {
  set_has_date();
  date_ = value;
}

// optional string extra = 6;
inline bool Message::has_extra() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Message::set_has_extra() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Message::clear_has_extra() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Message::clear_extra() {
  if (extra_ != &::google::protobuf::internal::kEmptyString) {
    extra_->clear();
  }
  clear_has_extra();
}
inline const ::std::string& Message::extra() const {
  return *extra_;
}
inline void Message::set_extra(const ::std::string& value) {
  set_has_extra();
  if (extra_ == &::google::protobuf::internal::kEmptyString) {
    extra_ = new ::std::string;
  }
  extra_->assign(value);
}
inline void Message::set_extra(const char* value) {
  set_has_extra();
  if (extra_ == &::google::protobuf::internal::kEmptyString) {
    extra_ = new ::std::string;
  }
  extra_->assign(value);
}
inline void Message::set_extra(const char* value, size_t size) {
  set_has_extra();
  if (extra_ == &::google::protobuf::internal::kEmptyString) {
    extra_ = new ::std::string;
  }
  extra_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Message::mutable_extra() {
  set_has_extra();
  if (extra_ == &::google::protobuf::internal::kEmptyString) {
    extra_ = new ::std::string;
  }
  return extra_;
}
inline ::std::string* Message::release_extra() {
  clear_has_extra();
  if (extra_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = extra_;
    extra_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Message::set_allocated_extra(::std::string* extra) {
  if (extra_ != &::google::protobuf::internal::kEmptyString) {
    delete extra_;
  }
  if (extra) {
    set_has_extra();
    extra_ = extra;
  } else {
    clear_has_extra();
    extra_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// MessageResponse

// required string message_id = 1;
inline bool MessageResponse::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MessageResponse::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MessageResponse::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MessageResponse::clear_message_id() {
  if (message_id_ != &::google::protobuf::internal::kEmptyString) {
    message_id_->clear();
  }
  clear_has_message_id();
}
inline const ::std::string& MessageResponse::message_id() const {
  return *message_id_;
}
inline void MessageResponse::set_message_id(const ::std::string& value) {
  set_has_message_id();
  if (message_id_ == &::google::protobuf::internal::kEmptyString) {
    message_id_ = new ::std::string;
  }
  message_id_->assign(value);
}
inline void MessageResponse::set_message_id(const char* value) {
  set_has_message_id();
  if (message_id_ == &::google::protobuf::internal::kEmptyString) {
    message_id_ = new ::std::string;
  }
  message_id_->assign(value);
}
inline void MessageResponse::set_message_id(const char* value, size_t size) {
  set_has_message_id();
  if (message_id_ == &::google::protobuf::internal::kEmptyString) {
    message_id_ = new ::std::string;
  }
  message_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MessageResponse::mutable_message_id() {
  set_has_message_id();
  if (message_id_ == &::google::protobuf::internal::kEmptyString) {
    message_id_ = new ::std::string;
  }
  return message_id_;
}
inline ::std::string* MessageResponse::release_message_id() {
  clear_has_message_id();
  if (message_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = message_id_;
    message_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MessageResponse::set_allocated_message_id(::std::string* message_id) {
  if (message_id_ != &::google::protobuf::internal::kEmptyString) {
    delete message_id_;
  }
  if (message_id) {
    set_has_message_id();
    message_id_ = message_id;
  } else {
    clear_has_message_id();
    message_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bool status = 2;
inline bool MessageResponse::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MessageResponse::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MessageResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MessageResponse::clear_status() {
  status_ = false;
  clear_has_status();
}
inline bool MessageResponse::status() const {
  return status_;
}
inline void MessageResponse::set_status(bool value) {
  set_has_status();
  status_ = value;
}

// optional string extra = 3;
inline bool MessageResponse::has_extra() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MessageResponse::set_has_extra() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MessageResponse::clear_has_extra() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MessageResponse::clear_extra() {
  if (extra_ != &::google::protobuf::internal::kEmptyString) {
    extra_->clear();
  }
  clear_has_extra();
}
inline const ::std::string& MessageResponse::extra() const {
  return *extra_;
}
inline void MessageResponse::set_extra(const ::std::string& value) {
  set_has_extra();
  if (extra_ == &::google::protobuf::internal::kEmptyString) {
    extra_ = new ::std::string;
  }
  extra_->assign(value);
}
inline void MessageResponse::set_extra(const char* value) {
  set_has_extra();
  if (extra_ == &::google::protobuf::internal::kEmptyString) {
    extra_ = new ::std::string;
  }
  extra_->assign(value);
}
inline void MessageResponse::set_extra(const char* value, size_t size) {
  set_has_extra();
  if (extra_ == &::google::protobuf::internal::kEmptyString) {
    extra_ = new ::std::string;
  }
  extra_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MessageResponse::mutable_extra() {
  set_has_extra();
  if (extra_ == &::google::protobuf::internal::kEmptyString) {
    extra_ = new ::std::string;
  }
  return extra_;
}
inline ::std::string* MessageResponse::release_extra() {
  clear_has_extra();
  if (extra_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = extra_;
    extra_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MessageResponse::set_allocated_extra(::std::string* extra) {
  if (extra_ != &::google::protobuf::internal::kEmptyString) {
    delete extra_;
  }
  if (extra) {
    set_has_extra();
    extra_ = extra;
  } else {
    clear_has_extra();
    extra_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ReceiveMessageAck

// required string message_id = 1;
inline bool ReceiveMessageAck::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReceiveMessageAck::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReceiveMessageAck::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReceiveMessageAck::clear_message_id() {
  if (message_id_ != &::google::protobuf::internal::kEmptyString) {
    message_id_->clear();
  }
  clear_has_message_id();
}
inline const ::std::string& ReceiveMessageAck::message_id() const {
  return *message_id_;
}
inline void ReceiveMessageAck::set_message_id(const ::std::string& value) {
  set_has_message_id();
  if (message_id_ == &::google::protobuf::internal::kEmptyString) {
    message_id_ = new ::std::string;
  }
  message_id_->assign(value);
}
inline void ReceiveMessageAck::set_message_id(const char* value) {
  set_has_message_id();
  if (message_id_ == &::google::protobuf::internal::kEmptyString) {
    message_id_ = new ::std::string;
  }
  message_id_->assign(value);
}
inline void ReceiveMessageAck::set_message_id(const char* value, size_t size) {
  set_has_message_id();
  if (message_id_ == &::google::protobuf::internal::kEmptyString) {
    message_id_ = new ::std::string;
  }
  message_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReceiveMessageAck::mutable_message_id() {
  set_has_message_id();
  if (message_id_ == &::google::protobuf::internal::kEmptyString) {
    message_id_ = new ::std::string;
  }
  return message_id_;
}
inline ::std::string* ReceiveMessageAck::release_message_id() {
  clear_has_message_id();
  if (message_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = message_id_;
    message_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReceiveMessageAck::set_allocated_message_id(::std::string* message_id) {
  if (message_id_ != &::google::protobuf::internal::kEmptyString) {
    delete message_id_;
  }
  if (message_id) {
    set_has_message_id();
    message_id_ = message_id;
  } else {
    clear_has_message_id();
    message_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 status = 2;
inline bool ReceiveMessageAck::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReceiveMessageAck::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReceiveMessageAck::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReceiveMessageAck::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 ReceiveMessageAck::status() const {
  return status_;
}
inline void ReceiveMessageAck::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
}

// optional string extra = 3;
inline bool ReceiveMessageAck::has_extra() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReceiveMessageAck::set_has_extra() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReceiveMessageAck::clear_has_extra() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReceiveMessageAck::clear_extra() {
  if (extra_ != &::google::protobuf::internal::kEmptyString) {
    extra_->clear();
  }
  clear_has_extra();
}
inline const ::std::string& ReceiveMessageAck::extra() const {
  return *extra_;
}
inline void ReceiveMessageAck::set_extra(const ::std::string& value) {
  set_has_extra();
  if (extra_ == &::google::protobuf::internal::kEmptyString) {
    extra_ = new ::std::string;
  }
  extra_->assign(value);
}
inline void ReceiveMessageAck::set_extra(const char* value) {
  set_has_extra();
  if (extra_ == &::google::protobuf::internal::kEmptyString) {
    extra_ = new ::std::string;
  }
  extra_->assign(value);
}
inline void ReceiveMessageAck::set_extra(const char* value, size_t size) {
  set_has_extra();
  if (extra_ == &::google::protobuf::internal::kEmptyString) {
    extra_ = new ::std::string;
  }
  extra_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReceiveMessageAck::mutable_extra() {
  set_has_extra();
  if (extra_ == &::google::protobuf::internal::kEmptyString) {
    extra_ = new ::std::string;
  }
  return extra_;
}
inline ::std::string* ReceiveMessageAck::release_extra() {
  clear_has_extra();
  if (extra_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = extra_;
    extra_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReceiveMessageAck::set_allocated_extra(::std::string* extra) {
  if (extra_ != &::google::protobuf::internal::kEmptyString) {
    delete extra_;
  }
  if (extra) {
    set_has_extra();
    extra_ = extra;
  } else {
    clear_has_extra();
    extra_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// NormalMessage

// required string message_id = 1;
inline bool NormalMessage::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NormalMessage::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NormalMessage::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NormalMessage::clear_message_id() {
  if (message_id_ != &::google::protobuf::internal::kEmptyString) {
    message_id_->clear();
  }
  clear_has_message_id();
}
inline const ::std::string& NormalMessage::message_id() const {
  return *message_id_;
}
inline void NormalMessage::set_message_id(const ::std::string& value) {
  set_has_message_id();
  if (message_id_ == &::google::protobuf::internal::kEmptyString) {
    message_id_ = new ::std::string;
  }
  message_id_->assign(value);
}
inline void NormalMessage::set_message_id(const char* value) {
  set_has_message_id();
  if (message_id_ == &::google::protobuf::internal::kEmptyString) {
    message_id_ = new ::std::string;
  }
  message_id_->assign(value);
}
inline void NormalMessage::set_message_id(const char* value, size_t size) {
  set_has_message_id();
  if (message_id_ == &::google::protobuf::internal::kEmptyString) {
    message_id_ = new ::std::string;
  }
  message_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NormalMessage::mutable_message_id() {
  set_has_message_id();
  if (message_id_ == &::google::protobuf::internal::kEmptyString) {
    message_id_ = new ::std::string;
  }
  return message_id_;
}
inline ::std::string* NormalMessage::release_message_id() {
  clear_has_message_id();
  if (message_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = message_id_;
    message_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NormalMessage::set_allocated_message_id(::std::string* message_id) {
  if (message_id_ != &::google::protobuf::internal::kEmptyString) {
    delete message_id_;
  }
  if (message_id) {
    set_has_message_id();
    message_id_ = message_id;
  } else {
    clear_has_message_id();
    message_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string receiver = 2;
inline bool NormalMessage::has_receiver() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NormalMessage::set_has_receiver() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NormalMessage::clear_has_receiver() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NormalMessage::clear_receiver() {
  if (receiver_ != &::google::protobuf::internal::kEmptyString) {
    receiver_->clear();
  }
  clear_has_receiver();
}
inline const ::std::string& NormalMessage::receiver() const {
  return *receiver_;
}
inline void NormalMessage::set_receiver(const ::std::string& value) {
  set_has_receiver();
  if (receiver_ == &::google::protobuf::internal::kEmptyString) {
    receiver_ = new ::std::string;
  }
  receiver_->assign(value);
}
inline void NormalMessage::set_receiver(const char* value) {
  set_has_receiver();
  if (receiver_ == &::google::protobuf::internal::kEmptyString) {
    receiver_ = new ::std::string;
  }
  receiver_->assign(value);
}
inline void NormalMessage::set_receiver(const char* value, size_t size) {
  set_has_receiver();
  if (receiver_ == &::google::protobuf::internal::kEmptyString) {
    receiver_ = new ::std::string;
  }
  receiver_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NormalMessage::mutable_receiver() {
  set_has_receiver();
  if (receiver_ == &::google::protobuf::internal::kEmptyString) {
    receiver_ = new ::std::string;
  }
  return receiver_;
}
inline ::std::string* NormalMessage::release_receiver() {
  clear_has_receiver();
  if (receiver_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = receiver_;
    receiver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NormalMessage::set_allocated_receiver(::std::string* receiver) {
  if (receiver_ != &::google::protobuf::internal::kEmptyString) {
    delete receiver_;
  }
  if (receiver) {
    set_has_receiver();
    receiver_ = receiver;
  } else {
    clear_has_receiver();
    receiver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bytes content = 3;
inline bool NormalMessage::has_content() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NormalMessage::set_has_content() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NormalMessage::clear_has_content() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NormalMessage::clear_content() {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& NormalMessage::content() const {
  return *content_;
}
inline void NormalMessage::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void NormalMessage::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void NormalMessage::set_content(const void* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NormalMessage::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  return content_;
}
inline ::std::string* NormalMessage::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NormalMessage::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int64 date = 4;
inline bool NormalMessage::has_date() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NormalMessage::set_has_date() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NormalMessage::clear_has_date() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NormalMessage::clear_date() {
  date_ = GOOGLE_LONGLONG(0);
  clear_has_date();
}
inline ::google::protobuf::int64 NormalMessage::date() const {
  return date_;
}
inline void NormalMessage::set_date(::google::protobuf::int64 value) {
  set_has_date();
  date_ = value;
}

// optional int32 expire = 5;
inline bool NormalMessage::has_expire() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void NormalMessage::set_has_expire() {
  _has_bits_[0] |= 0x00000010u;
}
inline void NormalMessage::clear_has_expire() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void NormalMessage::clear_expire() {
  expire_ = 0;
  clear_has_expire();
}
inline ::google::protobuf::int32 NormalMessage::expire() const {
  return expire_;
}
inline void NormalMessage::set_expire(::google::protobuf::int32 value) {
  set_has_expire();
  expire_ = value;
}

// optional string extra = 6;
inline bool NormalMessage::has_extra() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void NormalMessage::set_has_extra() {
  _has_bits_[0] |= 0x00000020u;
}
inline void NormalMessage::clear_has_extra() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void NormalMessage::clear_extra() {
  if (extra_ != &::google::protobuf::internal::kEmptyString) {
    extra_->clear();
  }
  clear_has_extra();
}
inline const ::std::string& NormalMessage::extra() const {
  return *extra_;
}
inline void NormalMessage::set_extra(const ::std::string& value) {
  set_has_extra();
  if (extra_ == &::google::protobuf::internal::kEmptyString) {
    extra_ = new ::std::string;
  }
  extra_->assign(value);
}
inline void NormalMessage::set_extra(const char* value) {
  set_has_extra();
  if (extra_ == &::google::protobuf::internal::kEmptyString) {
    extra_ = new ::std::string;
  }
  extra_->assign(value);
}
inline void NormalMessage::set_extra(const char* value, size_t size) {
  set_has_extra();
  if (extra_ == &::google::protobuf::internal::kEmptyString) {
    extra_ = new ::std::string;
  }
  extra_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NormalMessage::mutable_extra() {
  set_has_extra();
  if (extra_ == &::google::protobuf::internal::kEmptyString) {
    extra_ = new ::std::string;
  }
  return extra_;
}
inline ::std::string* NormalMessage::release_extra() {
  clear_has_extra();
  if (extra_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = extra_;
    extra_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NormalMessage::set_allocated_extra(::std::string* extra) {
  if (extra_ != &::google::protobuf::internal::kEmptyString) {
    delete extra_;
  }
  if (extra) {
    set_has_extra();
    extra_ = extra;
  } else {
    clear_has_extra();
    extra_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// NormalMessageAck

// required string message_id = 1;
inline bool NormalMessageAck::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NormalMessageAck::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NormalMessageAck::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NormalMessageAck::clear_message_id() {
  if (message_id_ != &::google::protobuf::internal::kEmptyString) {
    message_id_->clear();
  }
  clear_has_message_id();
}
inline const ::std::string& NormalMessageAck::message_id() const {
  return *message_id_;
}
inline void NormalMessageAck::set_message_id(const ::std::string& value) {
  set_has_message_id();
  if (message_id_ == &::google::protobuf::internal::kEmptyString) {
    message_id_ = new ::std::string;
  }
  message_id_->assign(value);
}
inline void NormalMessageAck::set_message_id(const char* value) {
  set_has_message_id();
  if (message_id_ == &::google::protobuf::internal::kEmptyString) {
    message_id_ = new ::std::string;
  }
  message_id_->assign(value);
}
inline void NormalMessageAck::set_message_id(const char* value, size_t size) {
  set_has_message_id();
  if (message_id_ == &::google::protobuf::internal::kEmptyString) {
    message_id_ = new ::std::string;
  }
  message_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NormalMessageAck::mutable_message_id() {
  set_has_message_id();
  if (message_id_ == &::google::protobuf::internal::kEmptyString) {
    message_id_ = new ::std::string;
  }
  return message_id_;
}
inline ::std::string* NormalMessageAck::release_message_id() {
  clear_has_message_id();
  if (message_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = message_id_;
    message_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NormalMessageAck::set_allocated_message_id(::std::string* message_id) {
  if (message_id_ != &::google::protobuf::internal::kEmptyString) {
    delete message_id_;
  }
  if (message_id) {
    set_has_message_id();
    message_id_ = message_id;
  } else {
    clear_has_message_id();
    message_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 status = 2;
inline bool NormalMessageAck::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NormalMessageAck::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NormalMessageAck::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NormalMessageAck::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 NormalMessageAck::status() const {
  return status_;
}
inline void NormalMessageAck::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
}

// optional string extra = 3;
inline bool NormalMessageAck::has_extra() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NormalMessageAck::set_has_extra() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NormalMessageAck::clear_has_extra() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NormalMessageAck::clear_extra() {
  if (extra_ != &::google::protobuf::internal::kEmptyString) {
    extra_->clear();
  }
  clear_has_extra();
}
inline const ::std::string& NormalMessageAck::extra() const {
  return *extra_;
}
inline void NormalMessageAck::set_extra(const ::std::string& value) {
  set_has_extra();
  if (extra_ == &::google::protobuf::internal::kEmptyString) {
    extra_ = new ::std::string;
  }
  extra_->assign(value);
}
inline void NormalMessageAck::set_extra(const char* value) {
  set_has_extra();
  if (extra_ == &::google::protobuf::internal::kEmptyString) {
    extra_ = new ::std::string;
  }
  extra_->assign(value);
}
inline void NormalMessageAck::set_extra(const char* value, size_t size) {
  set_has_extra();
  if (extra_ == &::google::protobuf::internal::kEmptyString) {
    extra_ = new ::std::string;
  }
  extra_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NormalMessageAck::mutable_extra() {
  set_has_extra();
  if (extra_ == &::google::protobuf::internal::kEmptyString) {
    extra_ = new ::std::string;
  }
  return extra_;
}
inline ::std::string* NormalMessageAck::release_extra() {
  clear_has_extra();
  if (extra_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = extra_;
    extra_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NormalMessageAck::set_allocated_extra(::std::string* extra) {
  if (extra_ != &::google::protobuf::internal::kEmptyString) {
    delete extra_;
  }
  if (extra) {
    set_has_extra();
    extra_ = extra;
  } else {
    clear_has_extra();
    extra_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace common

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::common::MessageCommand>() {
  return ::common::MessageCommand_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_MessageRouting_2eproto__INCLUDED
